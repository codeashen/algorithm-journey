# 从斐波那契数列看动态规划

斐波那契数列（Fibonacci Sequence），`F(0)=1, F(1)=1, ..., F(n)=F(n-1)+F(n-2) `，斐波那契数列是一个天然的递归表达式，可以很容易使用递归求出斐波那契数列第 n 项。

```java
/**
 * 递归求斐波那契数量第 n 项
 */
public int fib(int n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    return fib1(n - 1) + fib1(n - 2);
}
```

根据斐波那契数列的定义得到这样的递归程序，但是其效率是非常慢的，因为其间有很多次重复的递归计算。下图为程序求 `fib(5)` 的递归树，其中内一个节点都是一次递归调用，可以看到其中有很多重复的递归调用，以 fib(3) 为例，在计算 fib(4) 的时候需要计算 fib(3)，在计算 fib(5) 的时候还要重新计算 fib(3)，每次都要递归到底。

![image-20210826131700415](https://z3.ax1x.com/2021/08/26/hmHaVg.png)

有没有什么办法省略重复的递归算呢？可以使用记忆化搜索，记录下每次调用的结果，程序如下。

```java
public int fib(int n) {
    // 使用数组记录递归结果
    int[] memo = new int[n + 1];
    Arrays.fill(memo, -1);
    return memoryFib(n, memo);
}

/**
 * 记忆化搜索求斐波那契数列
 */
private int memoryFib(int n, int[] memo) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    // 优先取数组中的结果，没有才进行递归
    if (memo[n] == -1) {
        memo[n] = memoryFib(n - 1, memo) + memoryFib(n - 2, memo);
    }
    return memo[n];
}
```

可以看到记忆化搜索的实质就是在递归的基础上加上记忆化的过程，递归是 **自上而下** 的解决为题，换句话说，我们没有从最基本的问题开始解决，而是假设最基本的问题已经解决了，即假设我们已经会求 fib(n-1) 和 fib(n-2) 了，我们就能求出 fib(n)，在此基础上加上递归终止条件，就完成了一个递归程序。对于这类问题，如果我们能自上而下的解决问题的话，那我们也能自下而上的解决问题，如下程序。

```java
/**
 * 动态规划求斐波那契数列
 */
public int fib3(int n) {
    int[] memo = new int[n + 1];
    memo[0] = 0;
    memo[1] = 1;
    for (int i = 2; i <= n; i++) {
        memo[i] = memo[i - 1] + memo[i - 2];
    }
    return memo[n];
}
```

可以看到这个代码的非常简单的，也很容易分析出其时间复杂度是 O(n) 级别，时间复杂度和记忆化搜索大致也是一个级别的（记忆化搜索 fib 方法会被调用 2n-1 次），且没有递归调用。这样动态规划数组中的每个元素只会被访问 1 次，而记忆化搜索中数组元素会被访问多次，所以动态规划效率更高。

这样的解法即 **自下而上** 的解决问题，先考虑小数据量下的这个问题的结果是怎样的，之后层层递归来解决更大数据量的结果是怎样的，通常这个过程就被称之为 **动态规划**。对于斐波那契数列问题使用动态规划很简单，但是更复杂的问题可能很难想到。以下是维基百科对于动态规划的定义：

> 动态规划常常适用于有 `重叠子问题` 和 `最优子结构` 性质的问题，动态规划方法所耗时间往往远少于朴素解法。
>
> 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。
>
> 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其 `记忆化存储`，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

为了更容易理解，可以参考下图。大多数动态规划问题，其本质都是一个递归问题，只不过在递归过程中，会发现所谓的 `重叠子问题`，对于重叠子问题我们怎么处理，我们可以使用记忆化搜索的方式来处理，记忆化搜索的方式是一种自顶向下的解决问题的方式，另外一种处理方式其实就是动态规划，动态规划的本质在我看来和记忆化搜索是一样的，只不过他是自底向上的解决问题。

![image-20210826135441788](https://z3.ax1x.com/2021/08/26/hmzgLn.png)

在后续问题中，可以发现很多时候自定向上的解决问题是更容易的，有时候我们思考动态规划问题时会先自顶向下的思考问题，之后再用自底向上的方式实现。而事实上大多数时候记忆化搜索的方式都是能满足实际需求的，只不过使用动态规划的方式解决代码会更加简洁清晰。

# 第一个动态规划问题 Climbing Stairs

> [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)
>
> 假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

我们先自顶向下的思考问题的递归结构，我们爬到第 n 阶台阶的时候有两种可能，从 n-1 阶台阶再爬 1 阶，或者从 n-2 阶台阶再爬 2 阶。这样我们就把问题拆解成求爬上 n-1 阶和 n-2 阶台阶有多少种方法，两个结果相加就是爬上 n 阶台阶多有少种方法了。以此类推就形成了如下递归树，最后可以分解到求爬上 1 阶和 2 阶台阶分别有多少种方法，结果分别为climbStairs(1)=1，climbStairs(2)=2。

![image-20210826140823527](https://z3.ax1x.com/2021/08/26/hn98RU.png)

经过以上分析，可以写出以下程序。

```java
public int climbStairs(int n) {
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 2;
    }
    return climbStairs(n - 1) + climbStairs(n - 2);
}
```

可以发现这个代码和斐波那契数量非常相似。既然如此，自然能想到可以使用记忆化搜索的方式优化。

```java
class Solution {
    // 数组存放递归结果
    private int[] memo;

    public int climbStairs(int n) {
        // 初始化数组
        memo = new int[n + 1];
        Arrays.fill(memo, -1);
        return calcWays(n);
    }

    // 记忆化搜索方法
    private int calcWays(int n) {
        if (n == 1) {
            return 1;
        }
        if (n == 2) {
            return 2;
        }
        if (memo[n] == -1) {
            memo[n] = calcWays(n - 1) + calcWays(n - 2);
        }
        return memo[n];
    }
}
```

到这里我们应该可以进一步写出动态规划的解法。

```java
/**
 * 动态规划
 * 时间复杂度: O(n)
 * 空间复杂度: O(n)
 */
public int climbStairs(int n) {
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 2;
    }
    int[] memo = new int[n + 1];
    memo[1] = 1;
    memo[2] = 2;
    for (int i = 3; i <= n; i++) {
        memo[i] = memo[i - 1] + memo[i - 2];
    }
    return memo[n];
}
```

**LeetCode 相关练习题**

> [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)
>
> 给定一个三角形 triangle ，找出自顶向下的最小路径和。
>
> 每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。
>

> [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)
>
> 给定一个包含非负整数的 `m * n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

# 发现重叠子问题 Integer Break

> [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)
>
> 给定一个正整数 *n*，将其拆分为 `至少` 两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

刚拿到这个问题的时候，我们可能没有头绪，当我们没有头绪的时候可以首先考虑如何暴力求解，用什么样的方案才能将对正整数 n 的所有分割方式都枚举出来呢？我们不知道要做几重循环，考虑使用递归的方式。事实上这个问题使用暴力解法是一个回溯的算法，复杂的是指数级的，记作 O(2^n)。

以分割 4 为例，分析这个问题的递归树如下。

![image-20210826155439365](https://z3.ax1x.com/2021/08/26/hn0anK.png)

借此可以推导出分割正整数 n 的递归树。

![image-20210826155619562](https://z3.ax1x.com/2021/08/26/hnBCg1.png)

在分析出分割正整数的所有情况后，最后在所有情况里找到乘积的最大值就好了。和前面的例子一样，递归树中存在很多重叠子问题，这就提示我们可以使用记忆化搜索的方式来解决。

在这里介绍另一个概念：**最优子结构**。我们之所以可以使用这样的递归结构来解决这个问题是因为，求分割 n 获得的最大成绩，这是一个求最优化的问题，把它转化为求子问题的最优解，通过求子问题的最优解，可以获得原问题的最优解。这样的一个性质，叫做 **最优子结构**。

具体什么意思呢，我们再来看递归树，我们要想知道分割 n 获得的最大成绩，如果我们知道分割 n-1 的最大乘积、分割 n-2 的最大乘积……分割 1 获得的最大乘积，把这些答案综合起来，乘上线上的分割数字，我们就能知道分割 n 获得的最大乘积。换句话说，我们知道了子问题的最优解是多少，就能知道原问题的最优解是多少。

事实上也正是因为这个性质的存在，我们这棵递归树才得以存在，大家只要想清楚问题的递归结构，发现在这个递归结构中存在重叠子问题，其实我们就可以使用动态规划了。不过实际上严谨的来讲，看下图，对于一个递归问题，它应该同时满足重叠子问题和最优子结构这两个性质，这个情况这这个问题才能使用记忆化搜索和动态规划这两个方式来解决问题。

![image-20210826161209539](https://z3.ax1x.com/2021/08/26/hnslK1.png)

下面我们具体编码解决这个整数分割的问题，一步步实现暴力求解、记忆化搜索和动态规划。

1. 暴力求解

   ```java
   /**
    * 暴力递归
    * 时间复杂度: O(n^n)
    * 空间复杂度: O(n)
    */
   public class Solution { 
   	// 暴力递归解法
       public int integerBreak(int n) {
           if (n == 1) {
               return 1;
           }
   
           // 记录最大乘积
           int res = -1;
           // 这个循环表示每次都能将 n 分割成 i + (n-1) 的形式
           for (int i = 1; i <= n - 1; i++) {
               // 比较结果，注意这里要比较三个，要加上之分割两个的情况 i*(n-1)
               res = max3(res, i * (n - i), i * integerBreak(n - i));
           }
           return res;
       }
   
       // 辅助方法，求三个数的最大值
       private int max3(int a, int b, int c) {
           return Math.max(a, Math.max(b, c));
       }
   }
   ```

2. 记忆化搜索

   ```java
   /**
    * 记忆化搜索
    * 时间复杂度: O(n^2)
    * 空间复杂度: O(n)
    */
   public class Solution {
       // 存储子结果
       private int[] memo;
   
       public int integerBreak(int n) {
           memo = new int[n + 1];
           Arrays.fill(memo, -1);
           return integerBreakMemo(n);
       }
   
       // 记忆化搜索求解
       public int integerBreakMemo(int n) {
           if (n == 1) {
               return 1;
           }
           if (memo[n] != -1) {
               return memo[n];
           }
           // 记录最大乘积
           int res = -1;
           // 这个循环表示每次都能将 n 分割成 i + (n-1) 的形式
           for (int i = 1; i <= n - 1; i++) {
               // 比较结果，注意这里要比较三个，要加上之分割两个的情况 i*(n-1)
               res = max3(res, i * (n - i), i * integerBreakMemo(n - i));
           }
           memo[n] = res;
           return res;
       }
   
       // 辅助方法，求三个数的最大值
       private int max3(int a, int b, int c) {
           return Math.max(a, Math.max(b, c));
       }
   }
   
   ```

3. 动态规划

   ```java
   /**
    * 动态规划
    * 时间复杂度: O(n^2)
    * 空间复杂度: O(n)
    */
   public class Solution {
   	// 动态规划求解
       public int integerBreak(int n) {
           // 存储子结果
           int[] memo = new int[n + 1];
           memo[1] = 1;
           for (int i = 2; i <= n; i++) {  // 循环求解 meme[i]
               for (int j = 1; j <= i - 1; j++) {  // 对 i 有 j=i-1 种分割方式
                   // 这里需要对比三个数
                   // (1) 当前的 memo[i]
                   // (2) 只分割成两个数  j * (i-j)
                   // (3) 分割三个及以上  j * integerBreak(i-j) 
                   memo[i] = max3(memo[i], j * (i - j), j * memo[i - j]);
               }
           }
           return memo[n];
       }
   
       // 辅助方法，求三个数的最大值
       private int max3(int a, int b, int c) {
           return Math.max(a, Math.max(b, c));
       }
   }
   ```

**LeetCode 相关练习题**

> [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)
>
> 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
>
> 给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。
>
> 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
>

> [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)
>
> 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
>
> ```
> 'A' -> 1
> 'B' -> 2
> ...
> 'Z' -> 26
> ```
>
>
> 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：
>
> - "AAJF" ，将消息分组为 (1 1 10 6)
> - "KJF" ，将消息分组为 (11 10 6)
>
> 注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。
>
> 给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
>
> 题目数据保证答案肯定是一个 32 位 的整数。
>

>[62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)
>
>一个机器人位于一个 m * n 网格的左上角 （起始点在下图中标记为 “Start” ）。
>
>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
>
>问总共有多少条不同的路径？
>

>[63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)
>
>一个机器人位于一个 m * n 网格的左上角 （起始点在下图中标记为“Start” ）。
>
>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
>
>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
>

# 状态的定义和状态转移 House Robber

> [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)
>
> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
>
> - 如 [3, 4, 1, 2]，则返回 6 [3, (4), 1, (2)]
> - 如 [4, 3, 1, 2]，则返回 6 [(4), 3, 1, (2)]

暴力解法：检查所有房子的组合，对每一个组合，检查是否有相邻的房子，如果没有，记录其价值。找最大值。检查每种组合的复杂度是 O(n) 的，每个房子都有偷或不偷 2 种选择 ，共有 2^n 种组合，所示时间复杂的是 O((2^n)*n)。组合问题在之前介绍回溯的时候介绍过，忘记的不妨复习一下。这里的问题并不是让求所有的组合，而是让你求一个最大值，这是一个最优化问题，而它的解空间又是一个组合的解空间，我们很容易想到使用递归解决问题，那可以想一下会不会最终找到的递归结构中含有重叠子问题以及最优子结构这样的性质，进而我们就可以使用记忆化搜索以及动态规划来解决问题。

我们接下来分析一下，如果我们不是检查所有的组合，可以使用怎样的方法找到满足条件的不触发报警系统的情况。

对于 [0...n-1] 范围内的房子，我们先偷取的房子可以选择偷 0，1，...，n-1 号房子。假如我们最初偷取 0 号房子，那么接下来设立的子问题就是考虑偷取 [2...n-1] 号房子，因为必须跳过 1 号房子。以此类推，如果最初偷取 n-1 号房子，也就没有后续房子考虑了。按照上面的思路，可以继续分析递归树下一层的情况。

![image-20210826200709019](https://z3.ax1x.com/2021/08/26/hu8NA1.png)

最后得到的递归树，很容易看到存在着重叠子问题，与此同时每一个问题其实都是在求解一个最优化的值，那么子问题最优化的值，配合当前的决策，在每一步中选择一个最大值，就能得到原问题的最优解。相当于它也最优子结构的性质，我们就可以使用记忆化搜索或者动态规划的方式解决问题。

对于这个问题，我们在进行进一步的形式化的分析。我们在之前的递归树中，每一个节点其实表达的是我们要解决一个问题，即 **考虑** 偷取 [x...n-1] 范围里的房子`（函数的定义）`，我们每一个节点表示的要解决的问题在动态规划里通常称之为 **状态**，可以理解为递归函数中函数的定义。当我们完成了一个状态的定义之后，我们就要决定一个 **状态的转移**，即 `状态转移方程`：

- `f(0) = max { v(0)+f(2), v(1)+f(3), v(2)+f(4), ..., v(n-3)+f(n-1), v(n-2), v(n-1) }`

设置一个函数 f(x)，定义即为考虑偷取 [x...n-1] 范围里的房子的最优解，即上文中函数的定义。那么整个问题是说考虑偷取 [0...n-1] 范围里的房子的收益为大致，就是求解 f(0)。为了获得最大收益，我们就要求方程中 max 大括号里的最大值，也就是递归树第二层的所有节点，这里 `v(0)` 表示偷取 0 号房子的收益，首次决定偷取 0 号房子后能获得的最大收益为 `v(0)+f(2)`，即 0 号房子收益加上 [2...n-1] 范围内的最大收益，和递归树第二层第一个节点对应。以此类推，首次决定偷取 i 号房子后，可以获得的最大收益为 `v(i)+f(i+2)`。直到最后的 n-2 和 n-1 号房子，最大收益就是 `v(n-2)` 和 `v(n-1)`。

至此，我们介绍了动态规划的 **状态** 和 **状态转移**，之后的动态规划问题也要搞清楚其中的状态是什么，状态转移的什么。下面开始编码实现本题。

1. 记忆化搜索

   ```java
   /**
    * 记忆化搜索
    * 时间复杂度: O(n^2)
    * 空间复杂度: O(n)
    */
   public class Solution {
       // memo[i] 表示考虑抢劫 nums[i...n) 所能获得的最大收益
       private int[] memo;
   
       public int rob(int[] nums) {
           memo = new int[nums.length];
           Arrays.fill(memo, -1);
           return rangeRob(nums, 0);
       }
   
       // 偷取 nums[index...nums.length) 范围的房子的最大收益
       public int rangeRob(int[] nums, int index) {
           if (index >= nums.length) {
               return 0;
           }
           if (memo[index] != -1) {
               return memo[index];
           }
   
           int res = 0;
           for (int i = index; i < nums.length; i++) {
               res = Math.max(res, nums[index] + rangeRob(nums, index + 2));
           }
           memo[index] = res;
           return res;
       }
   }
   ```

2. 动态规划

   ```java
   /**
    * 动态规划
    * 时间复杂度: O(n^2)
    * 空间复杂度: O(n)
    */
   public class HouseRobber2 {
       public int rob(int[] nums) {
           int n = nums.length;
           if (n == 0) {
               return 0;
           }
   
           // memo[i] 表示考虑抢劫 nums[i...n) 所能获得的最大收益
           int[] memo = new int[n];
           memo[n - 1] = nums[n - 1];
           for (int i = n - 2; i >= 0; i--) {
               for (int j = i; j <= n - 1; j++) {
                   memo[i] = Math.max(memo[i], nums[j] + (j + 2 >= n ? 0 : memo[j + 2]));
               }
           }
           return memo[0];
       }
   }
   ```

动态规划问题需要明确状态的定义和状态的转移，本题我们对状态的定义是 `考虑偷取 [x...n-1] 范围里的房子`，并完成了代码实现。其实我们还可以将状态的定义设置为 `考虑偷取 [0...x] 范围里的房子`，大家可以思考这种定义下响应的逻辑变成了什么，即状态转移方程是什么，进一步思考如何代码实现。

**LeetCode 相关练习题**

> [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)
>
> 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。
>

> [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)
>
> 在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。
>
> 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。
>

> [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
>
> 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。
>
> 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
>
> - 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
> - 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

# 0-1 背包问题

之前我们介绍了很多动态规划问题，对于这些问题我们找到其中的递归结构，发现其中的重叠子问题和最优子结构，进而转化为动态规划问题。下面我们介绍一个 0-1 背包问题，它不是 leetcode 上的标准问题，但是非常经典，可以帮助我们进一步理解动态规划的设计思路。

> 0-1 背包问题
>
> 有一个背包，它的容量为 C（Capacity），现在有 n 种不同的物品，编号为 0...n-1，其中每一件物品的重量为 w(i)，价值为 v(i)。问可以向这个背包中盛放哪些物品，使得在不超过背包容量的基础上，物品的总价值最大。

同样的我们可以首先思考如果使用暴力解法应该怎样做。对于这个问题也是在 n 种不同的物品种挑出有限的物品，令其满足一个容量的限制，同时总和最大。我们相当于还是要求这 n 个物品的组合。每一件物品我们都可以选择放进去或者不放进去 2 个选择，共有 2^n 种组合，面对每一种组合还需要求出总重是多少，那么暴力解法的时间复杂度是 O((2^n)*n)。这类组合问题我们都可以使用递归的方式来求解，只是过程种我们考虑是否有重叠子问题和最优子结构，进而转化为动态规划问题。

另外可能有同学会思考是不是可以使用贪心算法求解本题，即优先放入平均价值高的物品，其实这样是有问题的。比如有以下三样物品，每样重量为 weight，价值为 value，单位价值为 v/w，那么单位价值最高的是 0、1 号物品。如果我们有一个容量为 5 的背包，优先放入单位价值高的物品，只能放得下 [0,1]，价值为 16。但是如果放入 [1,2]，价值为 22。所以本题不适用贪心算法。

![image-20210827081616890](https://z3.ax1x.com/2021/08/27/hKN9jf.png)

下面思考这个问题如何解决，考虑一个动态规划问题，首先要设立问题的状态，换言之，我们要设计一个递归函数，我们必须明确这个递归函数要完成什么事情，这里包括完成这个事情要哪些参数。之前我们介绍到的动态规划问题所设计的状态都是只用一个参数就解决了，通常我们问题种的参数的个数意味着我们要解决这个问题索要满足的约束条件。当前这个求最优解的背包问题有两个约束条件，分别为物品数量 n 和 背包容量 C，我们可以设立问题的状态为 F(n,C)，表示 `考虑将 n 个物品放进容量为 C 的背包，使得价值最大`。

明确了状态的定义后我们考虑如何设立这个状态的转移，这个状态的转移是这样的：

![image-20210827083317965](https://z3.ax1x.com/2021/08/27/hKUco4.png)

如果我们需要将 i 个物品放到容量为小 c 的背包中，我们可以有两种选择。

-  第 i 给物品不放入背包，此时问题的价值解为 `F(i-1, c)`
- 第 i 给物品放入背包，此时背包容量变为 `c-w(i)`，此时价值最优解为 `v(i) + F(i-1, c-w(i))`

这个任务面临的两种选择区别就是，对于第 i 个物品是否放入背包，然后在这两者之间选择一个最大值的策略。最后将这个过程整理一遍，就得到我们这个 0-1 背包问题的状态转移方程：

```
F(i, c) = max( F(i-1, c), v(i) + F(i-1, c-w(i)) )
```

得到了状态转移方程，我们下面来编码实现，先使用自顶向下的方式求解，大家可以看出这个状态转移方程正是自顶向下解决问题的思路，之后我们再把它改造为自底向上动态规划解决问题的思路。

1. 记忆化搜索

   ```java
   /**
    * 背包问题
    * 记忆化搜索
    * 时间复杂度: O(n*C) 其中 n 为物品个数; C 为背包容积
    * 空间复杂度: O(n*C)
    */
   public class Solution {
   
       // memo[i][c] 表示将 [0...i] 范围内的物品放入容量 c 的背包的最大价值
       private int[][] memo;
   
       /**
        * 求解背包问题
        *
        * @param w w[i] 表示第 i 号物品重量
        * @param v v[i] 表示第 i 号物品价值
        * @param C 背包容量
        * @return 返回可放置的最大价值
        */
       public int knapsack(int[] w, int[] v, int C) {
           if (w == null || v == null || w.length != v.length || C < 0) {
               throw new IllegalArgumentException("Invalid param.");
           }
   
           int n = w.length;
           if (n == 0 || C == 0) {
               return 0;
           }
   
           memo = new int[n][C + 1];
           for (int i = 0; i < n; i++) {
               for (int j = 0; j <= C; j++) {
                   memo[i][j] = -1;
               }
           }
           return bestValue(w, v, w.length - 1, C);
       }
   
       /**
        * 考虑将 [0...index] 个物品放进容量为 c 的背包，使价值最大
        *
        * @param w     物品重量
        * @param v     物品价值
        * @param index 考虑的物品范围 [0...index]
        * @param c     容量限制
        * @return 返回可放置的最大价值
        */
       private int bestValue(int[] w, int[] v, int index, int c) {
           if (c <= 0 || index < 0) {
               return 0;
           }
           if (memo[index][c] != -1) {
               return memo[index][c];
           }
   
           // 情况一：index 号物品不不放入
           int res = bestValue(w, v, index - 1, c);
           if (c >= w[index]) {
               // 情况二：index 号物品放入
               int otherRes = v[index] + bestValue(w, v, index - 1, c - w[index]);
               res = Math.max(res, otherRes);
           }
           return res;
       }
   }
   ```

2. 动态规划

   ```java
   /**
    * 背包问题
    * 动态规划
    * 时间复杂度: O(n*C) 其中 n 为物品个数; C 为背包容积
    * 空间复杂度: O(n*C)
    */
   public class Solution {
       /**
        * 求解背包问题
        *
        * @param w w[i] 表示第 i 号物品重量
        * @param v v[i] 表示第 i 号物品价值
        * @param C 背包容量
        * @return 返回可放置的最大价值
        */
       public int knapsack(int[] w, int[] v, int C) {
           if (w == null || v == null || w.length != v.length || C < 0) {
               throw new IllegalArgumentException("Invalid param.");
           }
   
           int n = w.length;
           if (n == 0 || C == 0) {
               return 0;
           }
   
           // memo[i][c] 表示将 [0...i] 范围内的物品放入容量 c 的背包的最大价值
           int[][] memo = new int[n][C + 1];
   
           // 首先确定 [0...0] 范围内物品放入背包的最大价值，只要不超过背包容量，最大价值就是 v[0]
           for (int j = 0; j <= C; j++) {   // 遍历任意容量，填充 v[0] 或 0
               memo[0][j] = j >= w[0] ? v[0] : 0;
           }
           
           for (int i = 1; i < n; i++) {       // 从 [0...1] 范围内物品开始考虑
               for (int j = 0; j <= C; j++) {  // 从背包容量为 [0...C] 考虑
                   // 情况一：i 号物品不放入
                   memo[i][j] = memo[i - 1][j];
                   if (j >= w[i]) {
                       // 情况二：i 号物品放入
                       int otherRes = v[i] + memo[i - 1][j - w[i]];
                       memo[i][j] = Math.max(memo[i][j], otherRes);  // 取较大值
                   }
               }
           }
   
           return memo[n - 1][C];
       }
   }
   ```

   

